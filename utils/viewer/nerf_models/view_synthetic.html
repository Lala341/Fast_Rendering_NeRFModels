<header>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
 

</header>
<div>
<!-- NavBar -->

<div class="container-fluid" style="position: fixed; top: 10%; left: 0%">
  <div class="row">
    
    <div class="col-md-9">
      <div id="container" >
  
      </div>
      
    </div>
    <div class="col-md-3">

    
      <p class="d-inline-flex gap-1">
        <div class="row">
        <div class="col-md-5">
        <a class="btn btn-dark w-100" data-bs-toggle="collapse" href="#collapseExample" role="button" aria-expanded="false" aria-controls="collapseExample" weight="80%">
          Options
        </a>
      </div>
        <div class="col-md-5">
 
         <a  class="btn btn-light dropdown-toggle w-100" type="button" data-bs-toggle="dropdown" aria-expanded="false" ">
          Datasets
          </a >
          <ul class="dropdown-menu">
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=chairBDRP">chair BDRP</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=chair">chair</a></li>

            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=drums">drums</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=drumsBDRP">drums BDRP</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=drumsBDRP2">drums BDRP2</a></li>

            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=ficus">ficus</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=hotdog">hotdog</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=lego">lego</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=materials">materials</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=mic">mic</a></li>
            <li><a class="dropdown-item" href="http://localhost:8000/view_synthetic.html?obj=ship">ship</a></li>

            
          </ul>

</div>
</div>
      </p>
      <div class="collapse" id="collapseExample">
        <div class="card card-body">
          
          <div style="margin: 20px;">
            
  <div >
    <label for="dampingFactorInput">Damping Factor:</label>
    <input type="range" id="dampingFactorInput" min="0" max="1" step="0.01" value="0.25" />
  </div>
  <div>
    <label for="zoomInput">Zoom Level:</label>
    <input type="range" id="zoomInput" min="0" max="100" value="50" />
   
  </div>
            <div >
              <button class="btn btn-light w-100 mt-2 mb-2" id="rotateButton">Rotate</button>
              
            </div>


            
            <div >
            <label for="toggleGrid">Toggle Grid:</label>
            <input type="checkbox" id="toggleGrid" checked />
          
            <label for="toggleAxes">Toggle Axes:</label>
            <input type="checkbox" id="toggleAxes" checked />
            
          </div>

          
          <div >
            <button class="btn btn-light w-100 mt-2 mb-2" id="save">Save</button>
            
          </div>


          <div >
            <br/>

            <br/>

            <h6>Scene editing:</h6>
            <h6>Interactive controls:</h6>

<br/>

<div>
  <button class="btn btn-light w-100 mt-2 mb-2" id="resetButton">Reset</button>

</div>
            <label for="toggleAxes">Deformation Y:</label>
            <input
            type="range"
            id="deformationInput"
            min="-10"
            max="10"
            step="0.01"
            value="1.0"
          />            
          </div>
        

          <div >
           
            <label for="toggleAxes">Deformation X:</label>
            <input
            type="range"
            id="deformationInputX"
            min="-10"
            max="10"
            step="0.01"
            value="1.0"
          />            
          </div>

          <div >
           
            <label for="toggleAxes">Deformation Z:</label>
            <input
            type="range"
            id="deformationInputZ"
            min="-10"
            max="10"
            step="0.01"
            value="1.0"
          />            
          </div>
        
        
          
          </div>


          
        </div>
      </div>
      <div>
        <br/>
      Information
      <br/>
      <br/>
      <div >
        Model: MobileNeRF BDPR
      </div>
      <div id="modelname"></div>
      <div id="sizelayout"></div>

          <div id="fpsdisplay"></div>
        <div id="sizedisplay"></div>
        <br/>
      </div>
      
    </div>
  </div>
</div>
  
  

</div>

<script id="gbuffer-frag" type="x-shader/x-fragment">
  precision highp float;

  layout(location = 0) out vec4 gColor0;
  layout(location = 1) out vec4 gColor1;
  layout(location = 2) out vec4 gColor2;

  uniform mediump sampler2D tDiffuse0;
  uniform mediump sampler2D tDiffuse1;

  in vec2 vUv;
  in vec3 vPosition;
  in vec3 rayDirection;

  void main() {

      // write color to G-Buffer
      gColor1 = texture( tDiffuse0, vUv );
      if (gColor1.r == 0.0) discard;
      gColor0 = vec4( normalize(rayDirection), 1.0 );
      gColor2 = texture( tDiffuse1, vUv );

  }
</script>

<!-- Read G-Buffer and render to screen -->
<script id="render-vert" type="x-shader/x-vertex">
  in vec3 position;
  in vec2 uv;

  out vec2 vUv;

  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;

  void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
</script>
<script id="gbuffer-vert" type="x-shader/x-vertex">
  in vec3 position;
  in vec2 uv;

  out vec2 vUv;
  out vec3 vPosition;
  out vec3 rayDirection;

  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;
  uniform mat4 modelMatrix;
  uniform vec3 cameraPosition;

  // Add deformation uniform
  uniform float deformationAmount;
  uniform float deformationAmountX;
  uniform float deformationAmountZ;

  void main() {
      vUv = uv;
      vPosition = position;

      // Apply deformation to chair mesh
      vec3 newPosition = position;
      newPosition.y *= deformationAmount; // Adjust the y-coordinate based on deformationAmount
      newPosition.x *= deformationAmountX; // Adjust the y-coordinate based on deformationAmount
      newPosition.z *= deformationAmountZ; // Adjust the y-coordinate based on deformationAmount

      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
      rayDirection = (modelMatrix * vec4(newPosition, 1.0)).rgb - cameraPosition;
  }
</script>






<script type="module">
  import * as THREE from "https://unpkg.com/three?module";

  import WebGL from "https://unpkg.com/three/examples/jsm/capabilities/WebGL.js?module";

  import { OBJLoader } from "https://unpkg.com/three/examples/jsm/loaders/OBJLoader.js?module";

  import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js?module";

  // copied and slightly modified from SNeRG

  //the MLP
  const viewDependenceNetworkShaderFunctions = `
    precision mediump float;

    layout(location = 0) out vec4 pc_FragColor;

    in vec2 vUv;

    uniform mediump sampler2D tDiffuse0x;
    uniform mediump sampler2D tDiffuse1x;
    uniform mediump sampler2D tDiffuse2x;

    uniform mediump sampler2D weightsZero;
    uniform mediump sampler2D weightsOne;
    uniform mediump sampler2D weightsTwo;

    mediump vec3 evaluateNetwork( mediump vec4 f0, mediump vec4 f1, mediump vec4 viewdir) {
        mediump float intermediate_one[NUM_CHANNELS_ONE] = float[](
            BIAS_LIST_ZERO
        );
        for (int j = 0; j < NUM_CHANNELS_ZERO; ++j) {
            mediump float input_value = 0.0;
            if (j < 4) {
            input_value =
                (j == 0) ? f0.r : (
                (j == 1) ? f0.g : (
                (j == 2) ? f0.b : f0.a));
            } else if (j < 8) {
            input_value =
                (j == 4) ? f1.r : (
                (j == 5) ? f1.g : (
                (j == 6) ? f1.b : f1.a));
            } else {
            input_value =
                (j == 8) ? viewdir.r : (
                (j == 9) ? -viewdir.b : viewdir.g); //switch y-z axes
            }
            for (int i = 0; i < NUM_CHANNELS_ONE; ++i) {
            intermediate_one[i] += input_value *
                texelFetch(weightsZero, ivec2(j, i), 0).x;
            }
        }
        mediump float intermediate_two[NUM_CHANNELS_TWO] = float[](
            BIAS_LIST_ONE
        );
        for (int j = 0; j < NUM_CHANNELS_ONE; ++j) {
            if (intermediate_one[j] <= 0.0) {
                continue;
            }
            for (int i = 0; i < NUM_CHANNELS_TWO; ++i) {
                intermediate_two[i] += intermediate_one[j] *
                    texelFetch(weightsOne, ivec2(j, i), 0).x;
            }
        }
        mediump float result[NUM_CHANNELS_THREE] = float[](
            BIAS_LIST_TWO
        );
        for (int j = 0; j < NUM_CHANNELS_TWO; ++j) {
            if (intermediate_two[j] <= 0.0) {
                continue;
            }
            for (int i = 0; i < NUM_CHANNELS_THREE; ++i) {
                result[i] += intermediate_two[j] *
                    texelFetch(weightsTwo, ivec2(j, i), 0).x;
            }
        }
        for (int i = 0; i < NUM_CHANNELS_THREE; ++i) {
            result[i] = 1.0 / (1.0 + exp(-result[i]));
        }
        return vec3(result[0]*viewdir.a+(1.0-viewdir.a),
                    result[1]*viewdir.a+(1.0-viewdir.a),
                    result[2]*viewdir.a+(1.0-viewdir.a));
      }


    void main() {

        vec4 diffuse0 = texture( tDiffuse0x, vUv );
        if (diffuse0.a < 0.6) discard;
        vec4 diffuse1 = texture( tDiffuse1x, vUv );
        vec4 diffuse2 = texture( tDiffuse2x, vUv );

        //deal with iphone
        diffuse0.a = diffuse0.a*2.0-1.0;
        diffuse1.a = diffuse1.a*2.0-1.0;
        diffuse2.a = diffuse2.a*2.0-1.0;

        //pc_FragColor.rgb  = diffuse1.rgb;
        pc_FragColor.rgb = evaluateNetwork(diffuse1,diffuse2,diffuse0);
        pc_FragColor.a = 1.0;
    }
`;

  /**
   * Creates a data texture containing MLP weights.
   *
   * @param {!Object} network_weights
   * @return {!THREE.DataTexture}
   */
  function createNetworkWeightTexture(network_weights) {
    let width = network_weights.length;
    let height = network_weights[0].length;

    let weightsData = new Float32Array(width * height);
    for (let co = 0; co < height; co++) {
      for (let ci = 0; ci < width; ci++) {
        let index = co * width + ci;
        let weight = network_weights[ci][co];
        weightsData[index] = weight;
      }
    }
    let texture = new THREE.DataTexture(
      weightsData,
      width,
      height,
      THREE.RedFormat,
      THREE.FloatType
    );
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.needsUpdate = true;
    return texture;
  }

  /**
   * Creates shader code for the view-dependence MLP.
   *
   * This populates the shader code in viewDependenceNetworkShaderFunctions with
   * network weights and sizes as compile-time constants. The result is returned
   * as a string.
   *
   * @param {!Object} scene_params
   * @return {string}
   */
  function createViewDependenceFunctions(network_weights) {
    let width = network_weights["0_bias"].length;
    let biasListZero = "";
    for (let i = 0; i < width; i++) {
      let bias = network_weights["0_bias"][i];
      biasListZero += Number(bias).toFixed(7);
      if (i + 1 < width) {
        biasListZero += ", ";
      }
    }

    width = network_weights["1_bias"].length;
    let biasListOne = "";
    for (let i = 0; i < width; i++) {
      let bias = network_weights["1_bias"][i];
      biasListOne += Number(bias).toFixed(7);
      if (i + 1 < width) {
        biasListOne += ", ";
      }
    }

    width = network_weights["2_bias"].length;
    let biasListTwo = "";
    for (let i = 0; i < width; i++) {
      let bias = network_weights["2_bias"][i];
      biasListTwo += Number(bias).toFixed(7);
      if (i + 1 < width) {
        biasListTwo += ", ";
      }
    }

    let channelsZero = network_weights["0_weights"].length;
    let channelsOne = network_weights["0_bias"].length;
    let channelsTwo = network_weights["1_bias"].length;
    let channelsThree = network_weights["2_bias"].length;

    let fragmentShaderSource = viewDependenceNetworkShaderFunctions.replace(
      new RegExp("NUM_CHANNELS_ZERO", "g"),
      channelsZero
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("NUM_CHANNELS_ONE", "g"),
      channelsOne
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("NUM_CHANNELS_TWO", "g"),
      channelsTwo
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("NUM_CHANNELS_THREE", "g"),
      channelsThree
    );

    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("BIAS_LIST_ZERO", "g"),
      biasListZero
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("BIAS_LIST_ONE", "g"),
      biasListOne
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("BIAS_LIST_TWO", "g"),
      biasListTwo
    );

    return fragmentShaderSource;
  }

  let container;

  let camera, scene, renderer, controls;
  let renderTarget;
  let postScene, postCamera;

  let gLastFrame = window.performance.now();
  let oldMilliseconds = 1000;

  const preset_size_w = 900;
  const preset_size_h = 800;
  const object_rescale = 0.1;

  init();

  function init() {
    const params = new URL(window.location.href).searchParams;
    const objname = params.get("obj");

    let obj_name = "ficus";
    if (objname) {
      obj_name = objname;

    }
    document.getElementById("modelname").innerHTML =
      "Object: " + obj_name;

    document.getElementById("sizelayout").innerHTML =
      "Size: " + preset_size_w +"x"+preset_size_h;

    var OBJFile = obj_name + "_phone/shape.obj";
    var PNGFile = obj_name + "_phone/shape.png";
    var JSONFile = obj_name + "_phone/mlp.json";

    if (WebGL.isWebGL2Available() === false) {
      document.body.appendChild(WebGL.getWebGL2ErrorMessage());
      return;
    }

    container = document.getElementById("container");
    renderer = new THREE.WebGLRenderer({
      powerPreference: "high-performance",
      precision: "highp",

      preserveDrawingBuffer: true, //edit
    });
    renderer.setPixelRatio(1);
    renderer.setSize(preset_size_w, preset_size_h);
    renderer.setClearColor(new THREE.Color("rgb(0, 0, 0)"), 0.5);
    container.appendChild(renderer.domElement);

    // Create a multi render target with Float buffers
    renderTarget = new THREE.WebGLMultipleRenderTargets(
      preset_size_w * 2,
      preset_size_h * 2,
      3
    );

    for (let i = 0, il = renderTarget.texture.length; i < il; i++) {
      renderTarget.texture[i].minFilter = THREE.LinearFilter;
      renderTarget.texture[i].magFilter = THREE.LinearFilter;
      renderTarget.texture[i].type = THREE.FloatType;
    }

    camera = new THREE.PerspectiveCamera(
      39,
      preset_size_w / preset_size_h,
      2 * object_rescale,
      6 * object_rescale
    );
    camera.position.y = 2.0 * object_rescale;
    camera.position.z = 3.464 * object_rescale;

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.screenSpacePanning = true;
    controls.ena = true;

    scene = new THREE.Scene();

    fetch(obj_name + "_phone/mlp.json")
      .then((response) => {
        return response.json();
      })
      .then((json) => {
        for (let i = 0, il = json["obj_num"]; i < il; i++) {
          let tex0 = new THREE.TextureLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".png" + "feat0.png",
            function () {
              render();
            }
          );
          tex0.magFilter = THREE.NearestFilter;
          tex0.minFilter = THREE.NearestFilter;
          let tex1 = new THREE.TextureLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".png" + "feat1.png",
            function () {
              render();
            }
          );
          tex1.magFilter = THREE.NearestFilter;
          tex1.minFilter = THREE.NearestFilter;
          let newmat = new THREE.RawShaderMaterial({
            side: THREE.DoubleSide,
            vertexShader: document.querySelector("#gbuffer-vert").textContent.trim(),
    fragmentShader: document.querySelector("#gbuffer-frag").textContent.trim(),
    uniforms: {
        tDiffuse0: { value: tex0 },
        tDiffuse1: { value: tex1 },
        deformationAmount: { value: 1.0 }, 
        deformationAmountX: { value: 1.0 }, 
        deformationAmountZ: { value: 1.0 }, 

    },
    glslVersion: THREE.GLSL3,
          });
          new OBJLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".obj",
            function (object) {
              object.traverse(function (child) {
                if (child.type == "Mesh") {
                  child.material = newmat;
                }
              });
              object.scale.x = object_rescale;
              object.scale.y = object_rescale;
              object.scale.z = object_rescale;
              scene.add(object);
            }
          );
        }

        let network_weights = json;
        let fragmentShaderSource =
          createViewDependenceFunctions(network_weights);
        let weightsTexZero = createNetworkWeightTexture(
          network_weights["0_weights"]
        );
        let weightsTexOne = createNetworkWeightTexture(
          network_weights["1_weights"]
        );
        let weightsTexTwo = createNetworkWeightTexture(
          network_weights["2_weights"]
        );

        // PostProcessing setup
        postScene = new THREE.Scene();
        postScene.background = new THREE.Color("rgb(255, 255, 255)");
        //postScene.background = new THREE.Color("rgb(128, 128, 128)");
        postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        postScene.add(
          new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            new THREE.RawShaderMaterial({
              vertexShader: document
                .querySelector("#render-vert")
                .textContent.trim(),
              fragmentShader: fragmentShaderSource,
              uniforms: {
                tDiffuse0x: { value: renderTarget.texture[0] },
                tDiffuse1x: { value: renderTarget.texture[1] },
                tDiffuse2x: { value: renderTarget.texture[2] },
                weightsZero: { value: weightsTexZero },
                weightsOne: { value: weightsTexOne },
                weightsTwo: { value: weightsTexTwo },

              },
              glslVersion: THREE.GLSL3,
            })
          )
        );

        window.addEventListener("resize", onWindowResize, false);

        animate();
      });
  }

  function onWindowResize() {
    camera.aspect = preset_size_w / preset_size_h;
    camera.updateProjectionMatrix();

    renderer.setSize(preset_size_w, preset_size_h);

    renderTarget.setSize(preset_size_w * 2, preset_size_h * 2);
    document.getElementById("sizedisplay").innerHTML =
      "Size: " + preset_size_w.toFixed(0) + "x" + preset_size_h.toFixed(0);

    render();
  }

  function updateFPSCounter() {
    let currentFrame = window.performance.now();
    let milliseconds = currentFrame - gLastFrame;
    let smoothMilliseconds = oldMilliseconds * 0.95 + milliseconds * 0.05;
    let smoothFps = 1000 / smoothMilliseconds;
    gLastFrame = currentFrame;
    oldMilliseconds = smoothMilliseconds;
    document.getElementById("fpsdisplay").innerHTML =
      "FPS: " + smoothFps.toFixed(1);
  }

  const startTime = performance.now();

    window.onload = function () {
        const endTime = performance.now();
        const pageLoadTime = endTime - startTime;
        console.log('Page Load Time:', pageLoadTime.toFixed(2), 'ms');
    };


  function getGPUAndFPSInfo() {
       // const canvas = document.createElement('canvas');
     //   const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        let fpsCounter = 0;
        let lastTimestamp = performance.now();

        function checkFPS(timestamp) {
            fpsCounter++;
            const elapsed = timestamp - lastTimestamp;

            if (elapsed >= 1000) { 
                const fps = (fpsCounter / elapsed) * 1000;
                console.log('FPS:', fps.toFixed(2));
                fpsCounter = 0;
                lastTimestamp = timestamp;
            }

            requestAnimationFrame(checkFPS);
        }

        requestAnimationFrame(checkFPS);

        function printMemoryUsage() {
        if ('performance' in window && 'memory' in performance) {
            const memoryInfo = performance.memory;

            console.log('Used JS Heap Size:', memoryInfo.usedJSHeapSize / (1024 * 1024), 'MB');
            console.log('JS Heap Size Limit:', memoryInfo.jsHeapSizeLimit / (1024 * 1024), 'MB');
        } else {
            console.warn('Memory information not available.');
        }
    }

    printMemoryUsage();

    }
    setInterval(getGPUAndFPSInfo, 2000);



    
    
    function saveAsImage() {
    var imgData, imgNode;

    try {
        var strMime = "image/jpeg";
        var strDownloadMime = "image/octet-stream";

        imgData = renderer.domElement.toDataURL(strMime);

        saveFile(imgData.replace(strMime, strDownloadMime), "test.jpg");

    } catch (e) {
        console.log(e);
        return;
    }

}

var saveFile = function (strData, filename) {
    var link = document.createElement('a');
    if (typeof link.download === 'string') {
        document.body.appendChild(link); //Firefox requires the link to be in the body
        link.download = filename;
        link.href = strData;
        link.click();
        document.body.removeChild(link); //remove the link when done
    } else {
        location.replace(uri);
    }
}
  document.getElementById("save").addEventListener("click", saveAsImage, false);
 






  function animate() {
    requestAnimationFrame(animate);

    controls.update();

    render();
  }

  function render() {
    // render scene into target
    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, camera);

    // render post FX
    renderer.setRenderTarget(null);
    renderer.render(postScene, postCamera);

    updateFPSCounter();
  }


  var zoomInput = document.getElementById('zoomInput');
  var rotateButton = document.getElementById('rotateButton');
  var dampingFactorInput = document.getElementById('dampingFactorInput');
  
  var toggleGrid = document.getElementById('toggleGrid');
  var toggleAxes = document.getElementById('toggleAxes');
  
  // Add event listeners to handle input changes
  toggleGrid.addEventListener('change', function () {
    scene.background = toggleGrid.checked ? null : new THREE.Color(0xf0f0f0);
  });

 
  
  // Add event listener to handle damping factor input change
  dampingFactorInput.addEventListener('input', function () {
    var dampingFactor = parseFloat(dampingFactorInput.value);
    controls.dampingFactor = dampingFactor;
  });
  // Add event listener to handle manual rotation button click
  rotateButton.addEventListener('click', function () {
    controls.autoRotate = !controls.autoRotate;
    controls.update();
  });
  // Add event listeners to handle control input changes
  zoomInput.addEventListener('input', function () {
    var zoomValue = parseFloat(zoomInput.value) / 50;
    camera.zoom = zoomValue;
    camera.updateProjectionMatrix();
  });


var resetButton = document.getElementById('resetButton');

let deformationInput = document.getElementById('deformationInput');
let deformationInputX = document.getElementById('deformationInputX');
let deformationInputZ = document.getElementById('deformationInputZ');

var deformationAmount = 1.0;
var deformationAmountX = 1.0;
var deformationAmountZ = 1.0;

deformationInput.addEventListener('input', function () {
  
  updateDeformation();
});
deformationInputX.addEventListener('input', function () {
  
  updateDeformation();
});
deformationInputZ.addEventListener('input', function () {
  
  updateDeformation();
});
// Add event listener to handle manual rotation button click
resetButton.addEventListener('click', function () {
  deformationAmount = 1.0;
  deformationAmountX = 1.0;
  deformationAmountZ =1.0;


    for(var i=0; i<scene.children.length;i++){

      if(scene.children[i].children!=undefined){
        let children=scene.children[i].children;

if (children.length>0 &&children[0].type == "Mesh") {
children[0].material.uniforms.deformationAmount.value = deformationAmount;
children[0].material.uniforms.deformationAmountX.value = deformationAmountX;
children[0].material.uniforms.deformationAmountZ.value = deformationAmountZ;

}
}    
    
    }
    render();
  });

function updateDeformation(){
  deformationAmount = parseFloat(deformationInput.value);
  deformationAmountX = parseFloat(deformationInputX.value);
  deformationAmountZ = parseFloat(deformationInputZ.value);

  console.log(deformationAmount);
  console.log(deformationAmountX);

    for(var i=0; i<scene.children.length;i++){

      if(scene.children[i].children!=undefined){
        let children=scene.children[i].children;

if (children.length>0 &&children[0].type == "Mesh") {
children[0].material.uniforms.deformationAmount.value = deformationAmount;
children[0].material.uniforms.deformationAmountX.value = deformationAmountX;
children[0].material.uniforms.deformationAmountZ.value = deformationAmountZ;

}
}    
    
    }
    render();
}

</script>
