<header>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
    crossorigin="anonymous"></script>


</header>
<div>
  <!-- NavBar -->

  <div class="container-fluid" style="position: fixed; top: 0%; left: 0%">
    <div class="row">

      <div>
        <div id="container" style="position: fixed; top: 70px;">

        </div>

      </div>
      <div style="position: absolute; top: 5%; right: 0%; width: 60%;">


        <p class="d-inline-flex gap-1">
        <div class="row">
          <div class="col-md-3">
            <a class="btn btn-dark w-100" data-bs-toggle="collapse" href="#collapseInformation" role="button"
              aria-expanded="false" aria-controls="collapseInformation" weight="80%">
              Metrics
            </a>
          </div>
          <div class="col-md-3">
            <a class="btn btn-dark w-100" data-bs-toggle="collapse" href="#collapseExample" role="button"
              aria-expanded="false" aria-controls="collapseExample" weight="80%">
              Options
            </a>
          </div>

          <div class="col-md-3">
            <a class="btn btn-dark w-100" data-bs-toggle="collapse" href="#collapseScene" role="button"
              aria-expanded="false" aria-controls="collapseScene" weight="80%">
              Scene
            </a>
          </div>
          <div class="col-md-3">

            <a class="btn btn-light dropdown-toggle w-100" type="button" data-bs-toggle="dropdown" aria-expanded="false" ">
          Datasets/Load
          </a >
          <ul class=" dropdown-menu">
              <li><a id="chairBDRP_red" class="dropdown-item">chair BDRP</a></li>
              <li><a id="chair_red" class="dropdown-item">chair</a></li>

              <li><a id="drums_red" class="dropdown-item">drums</a></li>
              <li><a id="drumsBDRP_red" class="dropdown-item">drums BDRP</a></li>
              <li><a id="drumsBDRP2_red" class="dropdown-item">drums BDRP2</a></li>

              <li><a id="ficus_red" class="dropdown-item">ficus</a></li>
              <li><a id="hotdog_red" class="dropdown-item">hotdog</a></li>
              <li><a id="lego_red" class="dropdown-item">lego</a></li>
              <li><a id="materials_red" class="dropdown-item">materials</a></li>
              <li><a id="mic_red" class="dropdown-item">mic</a></li>
              <li><a id="ship_red" class="dropdown-item">ship</a></li>


              </ul>

          </div>
        </div>
        </p>
        <div class="collapse pb-2" id="collapseExample" >
          <div class="card card-body">

            <div style="margin: 20px;">

              <div>
                <label for="dampingFactorInput">Damping Factor:</label>
                <input type="range" id="dampingFactorInput" min="0" max="1" step="0.01" value="0.25" />
              </div>
              <div>
                <label for="zoomInput">Zoom Level:</label>
                <input type="range" id="zoomInput" min="0" max="100" value="50" />

              </div>
              <div>
                <button class="btn btn-light w-100 mt-2 mb-2" id="rotateButton">Rotate</button>

              </div>



              <div>

                <div class="row">

                  <div class="col-5">
                    <label for="toggleGrid">Toggle Grid:</label>
                    <input type="checkbox" id="toggleGrid" />
                  </div>
                  <div class="col-5">

                    <label for="toggleAxes">Toggle Axes:</label>
                    <input type="checkbox" id="toggleAxes" />

                  </div>
                </div>




              </div>


              <div>
                <button class="btn btn-light w-100 mt-2 mb-2" id="save">Take screenshot</button>

              </div>


              <br />

              <h6>Camera:</h6>
              <div >
                <!-- First column -->
                <div class="row">
                  
                  <div class="col-3">
                    <label for="fovInput" class="mb-2">Field of View:</label>
                    <input type="number" id="fovInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" min="1" max="179" value="39">
                  </div>
                  <div class="col-3">
                    <label for="aspectInput" class="mb-2">Aspect Ratio:</label>
                    <input type="number" id="aspectInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" min="0.1" max="10" step="0.1" value="1">
                  </div>
                  <div class="col-3">
                    <label for="nearInput" class="mb-2">Near Plane:</label>
                    <input type="number" id="nearInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" min="0.1" max="100" step="0.1" value="2">
                  </div>
                  <div class="col-3">
                    <label for="farInput" class="mb-2">Far Plane:</label>
                    <br/>
                    <input type="number" id="farInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" min="1" max="1000" step="1" value="6">
                  </div>
                </div>
                <!-- Second column -->
                <div  class="row">
                  <div class="col-4">
                    <label for="positionXInput" class="mb-2">Camera Position X:</label>
                    <input type="number" id="positionXInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" value="0">
                  </div>
                  <div class="col-4">
                    <label for="positionYInput" class="mb-2">Camera Position Y:</label>
                    <input type="number" id="positionYInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" value="2">
                  </div>
                  <div class="col-4">
                    <label for="positionZInput" class="mb-2">Camera Position Z:</label>
                    <input type="number" id="positionZInput" class="border-gray-300 border rounded-md px-3 py-2 focus:outline-none focus:ring focus:ring-blue-200" value="3.464">
                  </div>
                </div>
              </div>
                <div>
                <br />

                <h6>Scene editing:</h6>
                <h6>Interactive controls:</h6>



                <label for="toggleAxes">Deformation Y:</label>
                <input type="range" id="deformationInput" min="-10" max="10" step="0.01" value="1.0" />
              </div>


              <div>

                <label for="toggleAxes">Deformation X:</label>
                <input type="range" id="deformationInputX" min="-10" max="10" step="0.01" value="1.0" />
              </div>

              <div>

                <label for="toggleAxes">Deformation Z:</label>
                <input type="range" id="deformationInputZ" min="-10" max="10" step="0.01" value="1.0" />
              </div>




              <div>
                <button class="btn btn-light w-100 mt-2 mb-2" id="resetButton">Reset</button>

              </div>


            </div>





          </div>
        </div>


        <div class="collapse pb-2" id="collapseScene"  >
          <div class="card card-body">

            <div style="margin: 20px; min-height: 50%;">


              <div class="table-responsive">
                <table class="table" id="layerTable">
                  <thead>
                    <tr>
                      <th scope="col">Object</th>
                      <th scope="col">Position(X)</th>
                      <th scope="col">Position(Y)</th>
                      <th scope="col">Position(Z)</th>
                      <th scope="col">Actions</th>
                    </tr>
                  </thead>
                  <tbody id="objectTableBody">
                    <tr>
                      <td style="width: 150px;">
                        <div class="dropdown" style="position: absolute;">
                          <button class="btn btn-light dropdown-toggle w-100" type="button" id="dropdownMenu"
                            data-bs-toggle="dropdown" aria-expanded="false">
                            Select object
                          </button>
                          <ul class="dropdown-menu" id="dropdownMenuItems">
                            <li><a id="chairBDRP" class="dropdown-item">chair BDRP</a></li>
                            <li><a id="chair" class="dropdown-item">chair</a></li>
                            <li><a id="drums" class="dropdown-item">drums</a></li>
                            <li><a id="drumsBDRP" class="dropdown-item">drums BDRP</a></li>
                            <li><a id="drumsBDRP2" class="dropdown-item">drums BDRP2</a></li>
                            <li><a id="ficus" class="dropdown-item">ficus</a></li>
                            <li><a id="hotdog" class="dropdown-item">hotdog</a></li>
                            <li><a id="lego" class="dropdown-item">lego</a></li>
                            <li><a id="materials" class="dropdown-item">materials</a></li>
                            <li><a id="mic" class="dropdown-item">mic</a></li>
                            <li><a id="ship" class="dropdown-item">ship</a></li>
                          </ul>
                        </div>
                      </td>
                      <td><input type="number" class="form-control" id="positionX" value="0.1"></td>
                      <td><input type="number" class="form-control" id="positionY" value="0.1"></td>
                      <td><input type="number" class="form-control" id="positionZ" value="0.1"></td>
                      <td><button class="btn btn-primary" id="buttonaddobject">Add</button></td>
                    </tr>
                  </tbody>
                </table>
              </div>





            </div>





          </div>
        </div>




        <div class="collapse pb-2" id="collapseInformation"  >
          <div class="card card-body">


            <div style="margin: 20px; min-height: 50%;">


              <div class="table-responsive">
                <table class="table">
                  <thead>
                    <tr>
                      <th scope="col">Metric</th>
                      <th scope="col">Value</th>
                    </tr>
                  </thead>
                  <tbody id="objectTableBody">
                    <tr>
                      <td class="px-4">Model:</td>
                      <td class="px-4">MobileNeRF</td>
                    </tr>
                    <tr>
                      <td class="px-4">Object:</td>
                      <td id="modelname" class="px-4"></td>
                    </tr>
                    <tr>
                      <td class="px-4">Size Layout:</td>
                      <td id="sizelayout" class="px-4"></td>
                    </tr>
                    <tr>
                      <td class="px-4">FPS:</td>
                      <td id="fpsdisplay" class="px-4"></td>
                    </tr>
                    <tr>
                      <td class="px-4">Used JS Heap:</td>
                      <td id="heapdisplay" class="px-4"></td>
                    </tr>
                    <tr>
                      <td class="px-4">Js Heap Size:</td>
                      <td id="heapdisplay2" class="px-4"></td>
                    </tr>
                    <tr>
                      <td class="px-4">Page load:</td>
                      <td id="heapdisplay3" class="px-4"></td>
                    </tr>
                  </tbody>
                </table>


              </div>
            </div>
          </div>

        </div>


      </div>
    </div>
  </div>

</div>

<script id="gbuffer-frag" type="x-shader/x-fragment">
  precision highp float;

  layout(location = 0) out vec4 gColor0;
  layout(location = 1) out vec4 gColor1;
  layout(location = 2) out vec4 gColor2;

  uniform mediump sampler2D tDiffuse0;
  uniform mediump sampler2D tDiffuse1;

  in vec2 vUv;
  in vec3 vPosition;
  in vec3 rayDirection;

  void main() {

      // write color to G-Buffer
      gColor1 = texture( tDiffuse0, vUv );
      if (gColor1.r == 0.0) discard;
      gColor0 = vec4( normalize(rayDirection), 1.0 );
      gColor2 = texture( tDiffuse1, vUv );

  }
</script>

<!-- Read G-Buffer and render to screen -->
<script id="render-vert" type="x-shader/x-vertex">
  in vec3 position;
  in vec2 uv;

  out vec2 vUv;

  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;

  void main() {
      vUv = uv;
      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
  }
</script>
<script id="gbuffer-vert" type="x-shader/x-vertex">
  in vec3 position;
  in vec2 uv;

  out vec2 vUv;
  out vec3 vPosition;
  out vec3 rayDirection;

  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;
  uniform mat4 modelMatrix;
  uniform vec3 cameraPosition;

  // Add deformation uniform
  uniform float deformationAmount;
  uniform float deformationAmountX;
  uniform float deformationAmountZ;

  void main() {
      vUv = uv;
      vPosition = position;

      // Apply deformation to chair mesh
      vec3 newPosition = position;
      newPosition.y *= deformationAmount; // Adjust the y-coordinate based on deformationAmount
      newPosition.x *= deformationAmountX; // Adjust the y-coordinate based on deformationAmount
      newPosition.z *= deformationAmountZ; // Adjust the y-coordinate based on deformationAmount

      gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0);
      rayDirection = (modelMatrix * vec4(newPosition, 1.0)).rgb - cameraPosition;
  }
</script>



<script type="module">
  import * as THREE from "https://unpkg.com/three?module";

  import WebGL from "https://unpkg.com/three/examples/jsm/capabilities/WebGL.js?module";

  import { OBJLoader } from "https://unpkg.com/three/examples/jsm/loaders/OBJLoader.js?module";

  import { OrbitControls } from "https://unpkg.com/three/examples/jsm/controls/OrbitControls.js?module";

  // copied and slightly modified from SNeRG

  //the MLP
  const viewDependenceNetworkShaderFunctions = `
    precision mediump float;

    layout(location = 0) out vec4 pc_FragColor;

    in vec2 vUv;

    uniform mediump sampler2D tDiffuse0x;
    uniform mediump sampler2D tDiffuse1x;
    uniform mediump sampler2D tDiffuse2x;

    uniform mediump sampler2D weightsZero;
    uniform mediump sampler2D weightsOne;
    uniform mediump sampler2D weightsTwo;

    mediump vec3 evaluateNetwork( mediump vec4 f0, mediump vec4 f1, mediump vec4 viewdir) {
        mediump float intermediate_one[NUM_CHANNELS_ONE] = float[](
            BIAS_LIST_ZERO
        );
        for (int j = 0; j < NUM_CHANNELS_ZERO; ++j) {
            mediump float input_value = 0.0;
            if (j < 4) {
            input_value =
                (j == 0) ? f0.r : (
                (j == 1) ? f0.g : (
                (j == 2) ? f0.b : f0.a));
            } else if (j < 8) {
            input_value =
                (j == 4) ? f1.r : (
                (j == 5) ? f1.g : (
                (j == 6) ? f1.b : f1.a));
            } else {
            input_value =
                (j == 8) ? viewdir.r : (
                (j == 9) ? -viewdir.b : viewdir.g); //switch y-z axes
            }
            for (int i = 0; i < NUM_CHANNELS_ONE; ++i) {
            intermediate_one[i] += input_value *
                texelFetch(weightsZero, ivec2(j, i), 0).x;
            }
        }
        mediump float intermediate_two[NUM_CHANNELS_TWO] = float[](
            BIAS_LIST_ONE
        );
        for (int j = 0; j < NUM_CHANNELS_ONE; ++j) {
            if (intermediate_one[j] <= 0.0) {
                continue;
            }
            for (int i = 0; i < NUM_CHANNELS_TWO; ++i) {
                intermediate_two[i] += intermediate_one[j] *
                    texelFetch(weightsOne, ivec2(j, i), 0).x;
            }
        }
        mediump float result[NUM_CHANNELS_THREE] = float[](
            BIAS_LIST_TWO
        );
        for (int j = 0; j < NUM_CHANNELS_TWO; ++j) {
            if (intermediate_two[j] <= 0.0) {
                continue;
            }
            for (int i = 0; i < NUM_CHANNELS_THREE; ++i) {
                result[i] += intermediate_two[j] *
                    texelFetch(weightsTwo, ivec2(j, i), 0).x;
            }
        }
        for (int i = 0; i < NUM_CHANNELS_THREE; ++i) {
            result[i] = 1.0 / (1.0 + exp(-result[i]));
        }
        return vec3(result[0]*viewdir.a+(1.0-viewdir.a),
                    result[1]*viewdir.a+(1.0-viewdir.a),
                    result[2]*viewdir.a+(1.0-viewdir.a));
      }


    void main() {

        vec4 diffuse0 = texture( tDiffuse0x, vUv );
        if (diffuse0.a < 0.6) discard;
        vec4 diffuse1 = texture( tDiffuse1x, vUv );
        vec4 diffuse2 = texture( tDiffuse2x, vUv );

        //deal with iphone
        diffuse0.a = diffuse0.a*2.0-1.0;
        diffuse1.a = diffuse1.a*2.0-1.0;
        diffuse2.a = diffuse2.a*2.0-1.0;

        //pc_FragColor.rgb  = diffuse1.rgb;
        pc_FragColor.rgb = evaluateNetwork(diffuse1,diffuse2,diffuse0);
        pc_FragColor.a = 1.0;
    }
`;

  /**
   * Creates a data texture containing MLP weights.
   *
   * @param {!Object} network_weights
   * @return {!THREE.DataTexture}
   */
  function createNetworkWeightTexture(network_weights) {
    let width = network_weights.length;
    let height = network_weights[0].length;

    let weightsData = new Float32Array(width * height);
    for (let co = 0; co < height; co++) {
      for (let ci = 0; ci < width; ci++) {
        let index = co * width + ci;
        let weight = network_weights[ci][co];
        weightsData[index] = weight;
      }
    }
    let texture = new THREE.DataTexture(
      weightsData,
      width,
      height,
      THREE.RedFormat,
      THREE.FloatType
    );
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.needsUpdate = true;
    return texture;
  }

  /**
   * Creates shader code for the view-dependence MLP.
   *
   * This populates the shader code in viewDependenceNetworkShaderFunctions with
   * network weights and sizes as compile-time constants. The result is returned
   * as a string.
   *
   * @param {!Object} scene_params
   * @return {string}
   */
  function createViewDependenceFunctions(network_weights, viewDependenceNetworkShaderFunctions) {
    let width = network_weights["0_bias"].length;
    let biasListZero = "";
    for (let i = 0; i < width; i++) {
      let bias = network_weights["0_bias"][i];
      biasListZero += Number(bias).toFixed(7);
      if (i + 1 < width) {
        biasListZero += ", ";
      }
    }

    width = network_weights["1_bias"].length;
    let biasListOne = "";
    for (let i = 0; i < width; i++) {
      let bias = network_weights["1_bias"][i];
      biasListOne += Number(bias).toFixed(7);
      if (i + 1 < width) {
        biasListOne += ", ";
      }
    }

    width = network_weights["2_bias"].length;
    let biasListTwo = "";
    for (let i = 0; i < width; i++) {
      let bias = network_weights["2_bias"][i];
      biasListTwo += Number(bias).toFixed(7);
      if (i + 1 < width) {
        biasListTwo += ", ";
      }
    }

    let channelsZero = network_weights["0_weights"].length;
    let channelsOne = network_weights["0_bias"].length;
    let channelsTwo = network_weights["1_bias"].length;
    let channelsThree = network_weights["2_bias"].length;

    let fragmentShaderSource = viewDependenceNetworkShaderFunctions.replace(
      new RegExp("NUM_CHANNELS_ZERO", "g"),
      channelsZero
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("NUM_CHANNELS_ONE", "g"),
      channelsOne
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("NUM_CHANNELS_TWO", "g"),
      channelsTwo
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("NUM_CHANNELS_THREE", "g"),
      channelsThree
    );

    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("BIAS_LIST_ZERO", "g"),
      biasListZero
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("BIAS_LIST_ONE", "g"),
      biasListOne
    );
    fragmentShaderSource = fragmentShaderSource.replace(
      new RegExp("BIAS_LIST_TWO", "g"),
      biasListTwo
    );

    return fragmentShaderSource;
  }

  let container;

  let camera, scene, renderer, controls;
  let renderTarget;
  let renderTarget2;

  let postScene, postCamera;
  let gLastFrame = window.performance.now();
  let oldMilliseconds = 1000;

  const preset_size_w = window.innerWidth; //COPY
  const preset_size_h = window.innerHeight - 70;
  const object_rescale = 0.1;

  init();


  function init() {
    const params = new URL(window.location.href).searchParams;
    const objname = params.get("obj");

    let obj_name = "ficus";
    if (objname) {
      obj_name = objname;

    }
    document.getElementById("modelname").innerHTML =
      obj_name;

    document.getElementById("sizelayout").innerHTML =
      preset_size_w + "x" + preset_size_h;

    var OBJFile = obj_name + "_phone/shape.obj";
    var PNGFile = obj_name + "_phone/shape.png";
    var JSONFile = obj_name + "_phone/mlp.json";

    if (WebGL.isWebGL2Available() === false) {
      document.body.appendChild(WebGL.getWebGL2ErrorMessage());
      return;
    }

    container = document.getElementById("container");
    renderer = new THREE.WebGLRenderer({
      powerPreference: "high-performance",
      precision: "highp",
      preserveDrawingBuffer: true, //edit
    });
    renderer.setPixelRatio(1);
    renderer.setSize(preset_size_w, preset_size_h);
    renderer.setClearColor(new THREE.Color("rgb(0, 0, 0)"), 0.5);
    container.appendChild(renderer.domElement);

    // Create a multi render target with Float buffers
    renderTarget = new THREE.WebGLMultipleRenderTargets(
      preset_size_w * 2,
      preset_size_h * 2,
      3
    );

    for (let i = 0, il = renderTarget.texture.length; i < il; i++) {
      renderTarget.texture[i].minFilter = THREE.LinearFilter;
      renderTarget.texture[i].magFilter = THREE.LinearFilter;
      renderTarget.texture[i].type = THREE.FloatType;
    }

    camera = new THREE.PerspectiveCamera(
      39,
      preset_size_w / preset_size_h,
      2 * object_rescale,
      6 * object_rescale
    );
    camera.position.y = 2.0 * object_rescale;
    camera.position.z = 3.464 * object_rescale;

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.screenSpacePanning = true;
    controls.ena = true;

    scene = new THREE.Scene();

    fetch(obj_name + "_phone/mlp.json")
      .then((response) => {
        return response.json();
      })
      .then((json) => {
        for (let i = 0, il = json["obj_num"]; i < il; i++) {
          let tex0 = new THREE.TextureLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".png" + "feat0.png",
            function () {
              render();
            }
          );
          tex0.magFilter = THREE.NearestFilter;
          tex0.minFilter = THREE.NearestFilter;
          let tex1 = new THREE.TextureLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".png" + "feat1.png",
            function () {
              render();
            }
          );
          tex1.magFilter = THREE.NearestFilter;
          tex1.minFilter = THREE.NearestFilter;
          let newmat = new THREE.RawShaderMaterial({
            side: THREE.DoubleSide,
            vertexShader: document.querySelector("#gbuffer-vert").textContent.trim(),
            fragmentShader: document.querySelector("#gbuffer-frag").textContent.trim(),
            uniforms: {
              tDiffuse0: { value: tex0 },
              tDiffuse1: { value: tex1 },
              deformationAmount: { value: 1.0 },
              deformationAmountX: { value: 1.0 },
              deformationAmountZ: { value: 1.0 },

            },
            glslVersion: THREE.GLSL3,
          });
          new OBJLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".obj",
            function (object) {
              object.traverse(function (child) {
                if (child.type == "Mesh") {
                  child.material = newmat;
                }
              });
              object.scale.x = object_rescale;
              object.scale.y = object_rescale;
              object.scale.z = object_rescale;
              scene.add(object);
            }
          );
        }

        let network_weights = json;
        let fragmentShaderSource =
          createViewDependenceFunctions(network_weights, viewDependenceNetworkShaderFunctions);
        let weightsTexZero = createNetworkWeightTexture(
          network_weights["0_weights"]
        );
        let weightsTexOne = createNetworkWeightTexture(
          network_weights["1_weights"]
        );
        let weightsTexTwo = createNetworkWeightTexture(
          network_weights["2_weights"]
        );

        // PostProcessing setup
        postScene = new THREE.Scene();
        postScene.background = new THREE.Color("rgb(255, 255, 255)");
        //postScene.background = new THREE.Color("rgb(128, 128, 128)");
        postCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        postScene.add(
          new THREE.Mesh(
            new THREE.PlaneGeometry(2, 2),
            new THREE.RawShaderMaterial({
              vertexShader: document
                .querySelector("#render-vert")
                .textContent.trim(),
              fragmentShader: fragmentShaderSource,
              uniforms: {
                tDiffuse0x: { value: renderTarget.texture[0] },
                tDiffuse1x: { value: renderTarget.texture[1] },
                tDiffuse2x: { value: renderTarget.texture[2] },
                weightsZero: { value: weightsTexZero },
                weightsOne: { value: weightsTexOne },
                weightsTwo: { value: weightsTexTwo },

              },
              glslVersion: THREE.GLSL3,
            })
          )
        );

        window.addEventListener("resize", onWindowResize, false);

        animate();
      });
  }



  let scene2, postScene2, postCamera2;
  var memoryInfo;
  var pageLoadTime;
  const startTime = performance.now();

  var zoomInput = document.getElementById('zoomInput');
  var rotateButton = document.getElementById('rotateButton');
  var dampingFactorInput = document.getElementById('dampingFactorInput');

  var toggleGridCheckbox = document.getElementById('toggleGrid');
  var toggleAxesCheckbox = document.getElementById('toggleAxes');
  var axesHelper; // Declare axesHelper variable globally
  var gridXZ;
  var gridXY;
  var gridYZ;

  var objects = [];
  var meshes = [];
  var objectNameAdd;





  function loadOther(obj_name, positionX, positionY, positionZ) {
    var position = new THREE.Vector3(positionX, positionY, positionZ);

    var OBJFile = obj_name + "_phone/shape.obj";
    var PNGFile = obj_name + "_phone/shape.png";
    var JSONFile = obj_name + "_phone/mlp.json";


    container = document.getElementById("container");

    //scene = new THREE.Scene();
    fetch(obj_name + "_phone/mlp.json")
      .then((response) => {
        return response.json();
      })
      .then((json) => {

        let temp_object = [];
        for (let i = 0, il = json["obj_num"]; i < il; i++) {
          let tex0 = new THREE.TextureLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".png" + "feat0.png",
            function () {
              render();
            }
          );
          tex0.magFilter = THREE.NearestFilter;
          tex0.minFilter = THREE.NearestFilter;
          let tex1 = new THREE.TextureLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".png" + "feat1.png",
            function () {
              render();
            }
          );

          tex1.magFilter = THREE.NearestFilter;
          tex1.minFilter = THREE.NearestFilter;
          let newmat = new THREE.RawShaderMaterial({
            side: THREE.DoubleSide,
            vertexShader: document.querySelector("#gbuffer-vert").textContent.trim(),
            fragmentShader: document.querySelector("#gbuffer-frag").textContent.trim(),
            uniforms: {
              tDiffuse0: { value: tex0 },
              tDiffuse1: { value: tex1 },
              deformationAmount: { value: 1.0 },
              deformationAmountX: { value: 1.0 },
              deformationAmountZ: { value: 1.0 },

            },
            glslVersion: THREE.GLSL3,
          });
          new OBJLoader().load(
            obj_name + "_phone/shape" + i.toFixed(0) + ".obj",
            function (object) {
              object.traverse(function (child) {
                if (child.type == "Mesh") {
                  child.material = newmat;
                }
              });
              object.position.copy(position); // Set position of the object

              object.scale.x = object_rescale;
              object.scale.y = object_rescale;
              object.scale.z = object_rescale;
              scene.add(object);
              temp_object.push(object);

            }
          );
        }
        let network_weights = json;
        let fragmentShaderSource =
          createViewDependenceFunctions(network_weights, viewDependenceNetworkShaderFunctions);
        let weightsTexZero = createNetworkWeightTexture(
          network_weights["0_weights"]
        );
        let weightsTexOne = createNetworkWeightTexture(
          network_weights["1_weights"]
        );
        let weightsTexTwo = createNetworkWeightTexture(
          network_weights["2_weights"]
        );

        const material2 = new THREE.RawShaderMaterial({
          vertexShader: document.querySelector("#render-vert").textContent.trim(),
          fragmentShader: fragmentShaderSource,
          uniforms: {
            tDiffuse0x: { value: renderTarget.texture[0] },
            tDiffuse1x: { value: renderTarget.texture[1] },
            tDiffuse2x: { value: renderTarget.texture[2] },
            weightsZero: { value: weightsTexZero },
            weightsOne: { value: weightsTexOne },
            weightsTwo: { value: weightsTexTwo },
          },
          glslVersion: THREE.GLSL3,
        });
        //const mesh2 = new THREE.Mesh(object.geometry, material2);
        const mesh2 = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), material2);
        //mesh2.position.copy(position); // Set position of the object
        //postScene2 = new THREE.Scene();
        // postScene2.background = new THREE.Color("rgb(255, 255, 255)");
        //postScene.background = new THREE.Color("rgb(128, 128, 128)");
        // postCamera2 = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        objects.push(temp_object);
        postScene.add(mesh2);
        meshes.push([mesh2]);
        render();

        // render scene into target
        // renderer.setRenderTarget(null);
        // renderer.render(postScene2, postCamera2);
      });
  }

  function onWindowResize() {
    camera.aspect = preset_size_w / preset_size_h;
    camera.updateProjectionMatrix();
    renderer.setSize(preset_size_w, preset_size_h);
    renderTarget.setSize(preset_size_w * 2, preset_size_h * 2);
    // renderTarget2.setSize(preset_size_w * 2, preset_size_h * 2);
    render();
  }

  function updateFPSCounter() {
    let currentFrame = window.performance.now();
    let milliseconds = currentFrame - gLastFrame;
    let smoothMilliseconds = oldMilliseconds * 0.95 + milliseconds * 0.05;
    let smoothFps = 1000 / smoothMilliseconds;
    gLastFrame = currentFrame;
    oldMilliseconds = smoothMilliseconds;
    document.getElementById("fpsdisplay").innerHTML =
      smoothFps.toFixed(1);

    if (memoryInfo) {
      document.getElementById("heapdisplay").innerHTML =
        (memoryInfo.usedJSHeapSize / (1024 * 1024)).toFixed(2) + 'MB';
      document.getElementById("heapdisplay2").innerHTML =
        (memoryInfo.jsHeapSizeLimit / (1024 * 1024)).toFixed(2) + 'MB';
      document.getElementById("heapdisplay3").innerHTML =
        pageLoadTime.toFixed(2) + 'ms';
    }

  }

  window.onload = function () {
    const endTime = performance.now();
    pageLoadTime = endTime - startTime;
    console.log('Page Load Time:', pageLoadTime.toFixed(2), 'ms');
  };


  function getGPUAndFPSInfo() {
    let fpsCounter = 0;
    let lastTimestamp = performance.now();

    function checkFPS(timestamp) {
      fpsCounter++;
      const elapsed = timestamp - lastTimestamp;

      if (elapsed >= 1000) {
        const fps = (fpsCounter / elapsed) * 1000;
        fpsCounter = 0;
        lastTimestamp = timestamp;
      }

      requestAnimationFrame(checkFPS);
    }

    requestAnimationFrame(checkFPS);

    function printMemoryUsage() {
      if ('performance' in window && 'memory' in performance) {
        memoryInfo = performance.memory;
        // console.log('Used JS Heap Size:', memoryInfo.usedJSHeapSize / (1024 * 1024), 'MB');
        //console.log('JS Heap Size Limit:', memoryInfo.jsHeapSizeLimit / (1024 * 1024), 'MB');
      }
    }

    printMemoryUsage();

  }
  setInterval(getGPUAndFPSInfo, 2000);


  function saveAsImage() {
    var imgData, imgNode;

    try {
      var strMime = "image/jpeg";
      var strDownloadMime = "image/octet-stream";

      imgData = renderer.domElement.toDataURL(strMime);

      saveFile(imgData.replace(strMime, strDownloadMime), "test.jpg");

    } catch (e) {
      console.log(e);
      return;
    }

  }

  var saveFile = function (strData, filename) {
    var link = document.createElement('a');
    if (typeof link.download === 'string') {
      document.body.appendChild(link); //Firefox requires the link to be in the body
      link.download = filename;
      link.href = strData;
      link.click();
      document.body.removeChild(link); //remove the link when done
    } else {
      location.replace(uri);
    }
  }
  document.getElementById("save").addEventListener("click", saveAsImage, false);


  function animate() {
    requestAnimationFrame(animate);
    controls.update();
    render();
  }

  function render() {
    // render scene into target
    renderer.setRenderTarget(renderTarget);
    renderer.render(scene, camera);
    renderer.setRenderTarget(null);
    renderer.render(postScene, postCamera);
    renderer.setRenderTarget(null);
    updateFPSCounter();
  }



  toggleGridCheckbox.addEventListener('change', function () {
    if (toggleGridCheckbox.checked) {
      gridXZ = new THREE.GridHelper(100, 10);
      //gridXZ.setColors(new THREE.Color(0x006600), new THREE.Color(0x006600));
      postScene.add(gridXZ);

      gridXY = new THREE.GridHelper(100, 10);
      gridXY.rotation.x = Math.PI / 2;
      //gridXY.setColors(new THREE.Color(0x000066), new THREE.Color(0x000066));
      postScene.add(gridXY);

      gridYZ = new THREE.GridHelper(100, 10);
      gridYZ.rotation.z = Math.PI / 2;
      //gridYZ.setColors(new THREE.Color(0x660000), new THREE.Color(0x660000));
      postScene.add(gridYZ);
    } else {
      postScene.remove(gridXZ);
      postScene.remove(gridXY);
      postScene.remove(gridYZ);
      gridXZ = undefined;
      gridXY = undefined;
      gridYZ = undefined;
    }
  });

  toggleAxesCheckbox.addEventListener('change', function () {
    if (toggleAxes.checked) {
      axesHelper = new THREE.AxesHelper(5);
      postScene.add(axesHelper);

    } else {
      if (axesHelper) {
        postScene.remove(axesHelper);
        axesHelper.dispose();
        axesHelper = null;
      }
    }
    render();
  });


  // Add event listener to handle damping factor input change
  dampingFactorInput.addEventListener('input', function () {
    var dampingFactor = parseFloat(dampingFactorInput.value);
    controls.dampingFactor = dampingFactor;
  });
  // Add event listener to handle manual rotation button click
  rotateButton.addEventListener('click', function () {
    controls.autoRotate = !controls.autoRotate;
    controls.update();
  });
  // Add event listeners to handle control input changes
  zoomInput.addEventListener('input', function () {
    var zoomValue = parseFloat(zoomInput.value) / 50;
    camera.zoom = zoomValue;
    camera.updateProjectionMatrix();
  });


  var resetButton = document.getElementById('resetButton');
  let deformationInput = document.getElementById('deformationInput');
  let deformationInputX = document.getElementById('deformationInputX');
  let deformationInputZ = document.getElementById('deformationInputZ');

  var deformationAmount = 1.0;
  var deformationAmountX = 1.0;
  var deformationAmountZ = 1.0;

  deformationInput.addEventListener('input', function () {

    updateDeformation();
  });
  deformationInputX.addEventListener('input', function () {

    updateDeformation();
  });
  deformationInputZ.addEventListener('input', function () {

    updateDeformation();
  });
  // Add event listener to handle manual rotation button click
  resetButton.addEventListener('click', function () {
    deformationAmount = 1.0;
    deformationAmountX = 1.0;
    deformationAmountZ = 1.0;


    for (var i = 0; i < scene.children.length; i++) {

      if (scene.children[i].children != undefined) {
        let children = scene.children[i].children;

        if (children.length > 0 && children[0].type == "Mesh") {
          children[0].material.uniforms.deformationAmount.value = deformationAmount;
          children[0].material.uniforms.deformationAmountX.value = deformationAmountX;
          children[0].material.uniforms.deformationAmountZ.value = deformationAmountZ;

        }
      }

    }
    render();
  });

  function updateDeformation() {
    deformationAmount = parseFloat(deformationInput.value);
    deformationAmountX = parseFloat(deformationInputX.value);
    deformationAmountZ = parseFloat(deformationInputZ.value);

    console.log(deformationAmount);
    console.log(deformationAmountX);

    for (var i = 0; i < scene.children.length; i++) {

      if (scene.children[i].children != undefined) {
        let children = scene.children[i].children;

        if (children.length > 0 && children[0].type == "Mesh") {
          children[0].material.uniforms.deformationAmount.value = deformationAmount;
          children[0].material.uniforms.deformationAmountX.value = deformationAmountX;
          children[0].material.uniforms.deformationAmountZ.value = deformationAmountZ;

        }
      }
    }
    render();
  }


  // Get the path part of the URL
  var path = window.location.pathname;

  // Remove parameters if any
  var currentHost = path.split('?')[0];
  // Get the current host URL

  // Dynamically set the href attributes of the dropdown items
  document.getElementById("chairBDRP_red").href = currentHost + "?obj=chairBDRP";
  document.getElementById("chair_red").href = currentHost + "?obj=chair";
  document.getElementById("drums_red").href = currentHost + "?obj=drums";
  document.getElementById("drumsBDRP_red").href = currentHost + "?obj=drumsBDRP";
  document.getElementById("drumsBDRP2_red").href = currentHost + "?obj=drumsBDRP2";
  document.getElementById("ficus_red").href = currentHost + "?obj=ficus";
  document.getElementById("hotdog_red").href = currentHost + "?obj=hotdog";
  document.getElementById("lego_red").href = currentHost + "?obj=lego";
  document.getElementById("materials_red").href = currentHost + "?obj=materials";
  document.getElementById("mic_red").href = currentHost + "?obj=mic";
  document.getElementById("ship_red").href = currentHost + "?obj=ship";



  function updateobject(index) {

    const positionX = parseFloat(document.getElementById("positionX").value);
    const positionY = parseFloat(document.getElementById("positionY").value);
    const positionZ = parseFloat(document.getElementById("positionZ").value);

    var position = new THREE.Vector3(positionX, positionY, positionZ);

    console.log(position);
    for (var i = 0; i < objects[index].length; i++) {
      objects[index][i].position.copy(position);

    }
    for (var i = 0; i < meshes[index].length; i++) {
      meshes[index][i].position.copy(position);

    }

    render();

  }

  function deletebject(index) {


    for (var i = 0; i < objects[index].length; i++) {
      scene.remove(objects[index][i]);

    }
    for (var i = 0; i < meshes[index].length; i++) {
      postScene.remove(meshes[index][i]);

    }
    var table = document.getElementById("layerTable");
    table.deleteRow(index + 2);
    objects.splice(index, 1);
    meshes.splice(index, 1);
    render();

  }

  function addNewObjectRow(name, x, y, z, index) {
    const tbody = document.getElementById("objectTableBody");
    const newRow = document.createElement("tr");

    newRow.innerHTML = `
    <td>${name}</td>
    <td><input type="number" class="form-control" id="positionX" value="${x}"></td>
    <td><input type="number" class="form-control" id="positionY" value="${y}"></td>
    <td><input type="number" class="form-control" id="positionZ" value="${z}"></td>
    <td><button class="btn btn-primary" id="updateobj-${index}">Update</button>
      <button class="btn btn-secondary" id="deleteobj-${index}">Delete</button></td>
  `;

    tbody.appendChild(newRow);


    var deletebutton = document.getElementById(`deleteobj-${index}`);

    deletebutton.addEventListener('click', function () {
      deletebject(index);
    });

    var updatebutton = document.getElementById(`updateobj-${index}`);

    updatebutton.addEventListener('click', function () {
      updateobject(index);
    });


  }

  let buttonaddobject = document.getElementById('buttonaddobject');

  buttonaddobject.addEventListener('click', function () {

    loadObject();
  });

  function loadObject() {
    if (objectNameAdd) {
      const objectNamet = objectNameAdd;


      const positionX = parseFloat(document.getElementById("positionX").value);
      const positionY = parseFloat(document.getElementById("positionY").value);
      const positionZ = parseFloat(document.getElementById("positionZ").value);

      // Call loadOther function with provided data
      loadOther(objectNamet, positionX, positionY, positionZ);
      addNewObjectRow(objectNamet, positionX, positionY, positionZ, objects.length);
      console.log("Selected object:", objectNamet);
    } else {
      console.log("No object selected.");
      alert("No object selected.");
    }


  }


  document.addEventListener("DOMContentLoaded", function () {
    const dropdownMenuItems = document.getElementById("dropdownMenuItems");
    const dropdownItems = dropdownMenuItems.querySelectorAll(".dropdown-item");

    dropdownItems.forEach(function (item) {
      item.addEventListener("click", function () {
        objectNameAdd = item.getAttribute("id");
        document.getElementById("dropdownMenu").textContent = item.textContent;
        document.getElementById("dropdownMenu").setAttribute("data-selected", objectNameAdd);
      });
    });
  });


  document.addEventListener('DOMContentLoaded', function () {
        var coll = document.querySelectorAll('[data-bs-toggle="collapse"]');

        coll.forEach(function (item) {
            item.addEventListener('click', function () {
                var target = document.querySelector(item.getAttribute('href'));
                var collapses = document.querySelectorAll('.collapse');
                collapses.forEach(function (collapse) {
                    if (collapse !== target && collapse.classList.contains('show')) {
                        collapse.classList.remove('show');
                    }
                });
            });
        });
    });



// Define variables for input fields
const fovInput = document.getElementById('fovInput');
const aspectInput = document.getElementById('aspectInput');
const nearInput = document.getElementById('nearInput');
const farInput = document.getElementById('farInput');
const positionXInput = document.getElementById('positionXInput');
const positionYInput = document.getElementById('positionYInput');
const positionZInput = document.getElementById('positionZInput');


fovInput.addEventListener('input', updateCamera);
  aspectInput.addEventListener('input', updateCamera);
  nearInput.addEventListener('input', updateCamera);
  farInput.addEventListener('input', updateCamera);
  positionXInput.addEventListener('input', updateCamera);
  positionYInput.addEventListener('input', updateCamera);
  positionZInput.addEventListener('input', updateCamera);

    // Function to update camera parameters
function updateCamera() {
  camera.fov = parseFloat(fovInput.value);
  camera.aspect = parseFloat(aspectInput.value);
  camera.near = parseFloat(nearInput.value);
  camera.far = parseFloat(farInput.value);
  camera.position.set(
    parseFloat(positionXInput.value),
    parseFloat(positionYInput.value),
    parseFloat(positionZInput.value)
  );
  camera.updateProjectionMatrix();
  render();
}
</script>